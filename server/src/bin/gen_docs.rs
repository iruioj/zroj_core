use server::app;

/// 添加 overload function declaration
fn gen_nuxt_wrapper(service: server::ServiceDoc) -> String {
    let mut r = String::new();

    service.apis.into_iter().for_each(|api| {
        let path = api.method.clone() + ":" + &service.path + &api.path;
        let res_ty = api.res_type.unwrap_or("void".into());
        // some invalid case
        if api.query_type.is_some() && api.body_type.is_some() {
            panic!("query conflict with body payload")
        }
        if api.query_type.is_some() && api.method != "get" {
            panic!("query should not by used for non-get api")
        }
        if api.method == "get" && api.body_type.is_some() {
            panic!("body should not by used for get api")
        }

        if let Some(ty) = api.body_type {
            r += &format!(
                "export function useAPI(path: {path:?}, payload: {ty}): Promise<{res_ty}>;\n"
            );
        } else if let Some(ty) = api.query_type {
            r += &format!(
                "export function useAPI(path: {path:?}, query: {ty}): Promise<{res_ty}>;\n"
            );
        } else {
            r += &format!("export function useAPI(path: {path:?}): Promise<{res_ty}>;\n");
        }
    });

    r
}

fn gen_nuxt_basic() -> String {
    r#"export function useAPI(path: string, args?: any): Promise<any> {
    const [method, slug] = path.split(':');
    if (args === undefined) {
        return useFetch(slug, { method: method as any });
    } else if (method === 'get') {
        return useFetch(slug, { method: method as any, query: args });
    } else {
        return useFetch(slug, { method: method as any, body: args });
    }
}
"#
    .into()
}

fn main() {
    let mut code = String::from("// generated by server/src/bin/gen_docs.rs\n// DO NOT EDIT.\n\n");
    code += &gen_nuxt_wrapper(app::auth::service_doc());
    code += &gen_nuxt_wrapper(app::user::service_doc());
    code += &gen_nuxt_basic();
    println!("{code}");
}
