use std::fs::DirBuilder;
use std::sync::RwLock;
use actix_web::{get, post, web, error::ErrorInternalServerError};
use actix_session::{Session};
use r2d2::State;
use serde::{Serialize, Deserialize};
use crate::{
    auth::{fetch_login_state, SessionContainer, LoginState},
    config::ServerConfig,
    schema::{
        ResponseMsg,
        response_msg,
        ResponseJsonData,
        response_json_data_false,
        response_json_data_true,
    }
};
use crate::auth::UserID;
type ProblemID = u32;
type GroupID = i32;


#[derive(Debug, Clone, Serialize, Deserialize)]
struct Static_Example {
    #[serde(rename = "Example Input")]
    input: String,
    #[serde(rename = "Example Output")]
    output: String
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Dynamic_Example {
    #[serde(rename = "Input Data")]
    input_path: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum Example {
    StaticExample(Static_Example),
    DynamicExample(Dynamic_Example),
}
#[derive(Debug, Clone, Serialize, Deserialize)]
enum RendererType {
    /// Render with markdown mathjax engine
    Markdown,
    /// Render with a polygon-like template & XeLatex
    /// Using LaTex must be rendered locally
    LaTex,
}

/// problem statement, stored in basedir{pid}/statement
#[derive(Debug, Clone, Serialize, Deserialize)]
struct Statement {
    /// problem name    
    #[serde(rename = "Renderer Type")]
    renderer_type: RendererType,
    #[serde(rename = "Name")]
    name: String,
    /// problem background & description
    #[serde(rename = "Legend")]
    legend: String,
    /// input format 
    #[serde(rename = "Input Format")]
    input_format: String,
    /// output format
    #[serde(rename = "Output Format")]
    output_format: String,
    /// notes & constraints & case/subtask specification
    #[serde(rename = "Notes")]
    notes: String,
    /// examples, either user input or generated by running a testcase
    #[serde(rename = "Examples")]
    examples: Vec <Example>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum ProblemIOType {
    /// read from stdin, write to stdout
    StandardIO,
    /// specify files to read and write
    /// some.in, some.out
    FileIO(String,String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum ProblemType {
    /// Traditional, also supports NOI style interactive problem
    Traditional(ProblemIOType),
    /// I/O Interactive Problem
    Interactive,
    /// Submit answer only
    AnswerOnly,
}


#[derive(Debug, Clone, Serialize, Deserialize)]
struct GeneralConfig {
    /// Problem type
    problem_type: ProblemType,
    /// Some problem may have different time limit on each testcase
    /// in which case should the Judger Parse the limit and return a {min}~{max}ms
    time_limit: String,
    /// Like time limit, but MB not ms
    memory_limit: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
enum UserGroup {
    user(UserID),
    group(GroupID),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ProblemConfig {
    general_config: GeneralConfig,
    viewers: Vec <UserGroup>,
    editors: Vec <UserGroup>,
}

#[derive(Debug, Clone, Serialize, Deserialize,PartialEq,PartialOrd)]
enum ProblemAccess {
    None = 0,
    View = 1,
    Edit = 2,
}


#[derive(Debug, Clone, Serialize, Deserialize)]
struct ProblemViewData {
    general_config: GeneralConfig,
    statement: Statement,
}

#[derive(Debug)]
pub struct ProblemManager {
    locks: Vec <RwLock<()> >,
    /// base directory of each problem
    base_dir: String,
    /// the json file that store problem statement
    statement: String,
    /// the directory that stores problem data
    data_dir: String,
    pid_maximum: ProblemID,
}
impl ProblemManager {
    pub fn new(config: &ServerConfig) -> Self {
        Self {
            locks: (0..config.pid_maximum).map(|_| RwLock::new(())).collect(),
            base_dir: config.problem_base_dir.clone(),
            statement: config.problem_statement.clone(),
            data_dir: config.problem_data_dir.clone(),
            pid_maximum: config.pid_maximum.clone(),
        }
    }
    fn fetch_file(&self, path: &String) -> actix_web::Result <String> {
        std::fs::read_to_string(path).
            map_err(|e| ErrorInternalServerError(e.to_string()))
    }
    fn get_base_dir(&self, pid: ProblemID) -> actix_web::Result <String> {
        let mut s = self.base_dir.clone();
        if let None = s.find("{}") {
            return Err(ErrorInternalServerError("Problem base dir is not correct. {} is required".to_string()));
        }
        s = s.replace("{}", &pid.to_string());
        if let Some(_) = s.find("{}") {
            return Err(ErrorInternalServerError("Problem base dir is not correct. Too many {}s".to_string()));
        }
        Ok(s)
    }
    fn read_statement(&self, pid: ProblemID) -> actix_web:: Result <String> {
        let guard = self.locks[pid as usize]
            .read()
            .map_err(|e| ErrorInternalServerError(e.to_string()))?;
        let dir = self.get_base_dir(pid)? + &self.statement;
        let result = self.fetch_file(&dir)?;
        drop(guard);
        Ok(result)
    }
    fn check_access(&self, pid: ProblemID, uid: UserID) -> actix_web::Result <ProblemAccess> {
        todo!()
    }
    fn fetch_view_data(&self, pid: ProblemID) -> actix_web::Result <ProblemViewData> {
        todo!()
    }
}

#[get("/{pid}")]
async fn view_problem(
    pid: web::Path<ProblemID>,
    session: Session,
    session_container: web::Data <SessionContainer>,
    manager: web::Data <ProblemManager>
) -> actix_web::Result <web::Json <ResponseJsonData <ProblemViewData> > > {
    if *pid >= manager.pid_maximum {
        return response_json_data_false("Problem does not exists");
    }
    let login_state = fetch_login_state(&session, &session_container)?;
    if let LoginState::UserID(uid) = login_state {
        if(manager.check_access(*pid, uid)? >= ProblemAccess::View) {
            response_json_data_true(manager.fetch_view_data(*pid)?)
        } else {
            response_json_data_false("You do not have access to this problem")
        }
    } else {
        response_json_data_false("Please login first")
    }
}

/*
#[get("/{pid}/edit")]
async fn edit(
    pid: web::Path<u32>,
    session: Session,
    session_container: web::Data <SessionContainer>,
    manager: web::Data <ProblemManager>
) -> actix_web::Result <web::Json <ResponseJsonData> > {
    if *pid >= manager.pid_maximum {
        return response_json_data(false, "Problem does not exists", "");
    }
    let uid = fetch_login_state(&session, &session_container)?;
    todo!()
}
*/

/// 提供 problem 的网络服务
pub fn service(
    session_containter: web::Data <SessionContainer>,
    manager: web::Data <ProblemManager>
) -> actix_web::Scope {
    web::scope("/api/problem")
        .app_data(session_containter)
        .app_data(manager)
        .service(view_problem)
        // .service(edit)
}
