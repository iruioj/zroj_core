//! specify how problem data is stored
use crate::auth::UserID;
use serde::{Deserialize, Serialize};
pub type ProblemID = u32;
pub type GroupID = i32;
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserGroup {
    User(UserID),
    Group(GroupID),
}

/// problem config, stored in config_path
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProblemConfig {
    pub general_config: GeneralConfig,
    pub owner: UserID,
    pub viewers: Vec<UserGroup>,
    pub editors: Vec<UserGroup>,
    pub open_source_data: bool,
}

/// problem statement, stored in self.statement_path
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Statement {
    Markdown(StatementSource),
    LaTex(StatementSource, String),
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]
pub enum ProblemAccess {
    /// None
    None = 0,
    /// view problem and test data structure, real data if config.open_data
    View = 1,
    /// view any, edit general
    Edit = 2,
    /// view and edit any, or delete a problem
    Admin = 3,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatementSource {
    /// problem background & description
    #[serde(rename = "Legend")]
    pub legend: String,
    /// input format
    #[serde(rename = "Input Format")]
    pub input_format: String,
    /// output format
    #[serde(rename = "Output Format")]
    pub output_format: String,
    /// notes & constraints & case/subtask specification
    #[serde(rename = "Notes")]
    pub notes: String,
    /// examples, either user input or generated by running a testcase
    #[serde(rename = "Examples")]
    pub examples: Vec<Example>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Example {
    pub case: ExampleCase,
    pub explanation: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExampleCase {
    Static(StaticExample),
    Dynamic(DynamicExample),
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StaticExample {
    #[serde(rename = "Example Input")]
    pub input: String,
    #[serde(rename = "Example Output")]
    pub output: String,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicExample {
    #[serde(rename = "Input Data")]
    pub input_path: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneralConfig {
    pub id: ProblemID,
    /// Some problem may have different time limit on each testcase
    /// in which case should the Judger Parse the limit and return a {min}~{max}ms
    pub time_limit: String,
    /// Like time limit, but MB not ms
    pub memory_limit: String,
    /// Problem type
    pub problem_type: ProblemType,
}
/// For traditional problem
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProblemIOType {
    /// read from stdin, write to stdout
    StandardIO,
    /// specify files to read and write
    /// some.in, some.out
    FileIO(String, String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProblemType {
    /// Traditional, also supports NOI style interactive problem
    Traditional(ProblemIOType),
    /// I/O Interactive Problem
    Interactive,
    /// Submit answer only
    SubmitAnswer,
    RemoteJudge(RemoteJudgeConfig),
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteJudgeConfig {
    pub oj: RemoteOJ,
    pub pid: ProblemID,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RemoteOJ {}
