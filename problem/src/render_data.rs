//! 题面、题解等前端渲染数据（markdown）
//!
//! 渲染数据不需要从设计上保证与评测数据的一致性（因为你也没法保证题面的准确性），需要出题人自己细心维护，
//! 或者借助造题工具来降低错误发生的几率。
//!
//! 渲染数据等源数据仍然与评测数据保存到一起，在 OJ 上在线修改时也需要做出相应的修改。遇到修改也是一样的处理。
//! 数据库里维护的是与搜索有关/已经渲染好的题面等等

use serde::{Deserialize, Serialize};
use serde_ts_typing::SerdeJsonWithType;
use std::path::PathBuf;

/// 描述一个文件
#[derive(Debug, Clone, Serialize, Deserialize, SerdeJsonWithType)]
pub enum FileDescriptor {
    Stdin,
    Stdout,
    Named(String),
}

/// for traditional problem
#[derive(Debug, Clone, Serialize, Deserialize, SerdeJsonWithType)]
pub enum IOKind {
    /// read from stdin, write to stdout
    StdIO,
    /// specify named files to read and write
    FileIO {
        input: FileDescriptor,
        output: FileDescriptor,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize, SerdeJsonWithType)]
pub enum ProblemKind {
    /// Traditional, also supports NOI style interactive problem
    Traditional(IOKind),
    /// I/O Interactive Problem
    Interactive,
    /// Submit answer only
    SubmitAnswer,
}

pub mod statement {
    use super::*;
    use judger::sandbox::{Elapse, Memory};

    /// 题面数据
    #[derive(Debug, Serialize, Deserialize)]
    pub struct Statement {
        /// 题面描述
        pub statement: Inner,
        /// 题目元数据
        pub meta: Meta,
    }

    /// problem statement, stored in self.statement_path
    #[derive(Debug, Serialize, Deserialize)]
    pub enum Inner {
        /// custom layout, only for import
        Legacy(String),
        /// standard form, consists of several pre-defined parts
        Standard {
            /// problem background & description
            legend: String,
            /// input format
            input_format: String,
            /// output format
            output_format: String,
            /// notes & constraints & case/subtask specification
            notes: String,
            /// examples, either user input or generated by running a testcase
            examples: Vec<IOData>,
        },
        /// load from an pdf asset
        Pdf(PathBuf),
    }

    impl Inner {
        // re-design
        pub fn render_html(&self) -> String {
            todo!()
        }
    }

    /// 样例
    ///
    /// 一个程序与静态数据的交互总是通过文件指针进行的，因此对于样例的结构也可以抽象为此。
    /// 不同类型的题目给出的样例不同。
    ///
    /// 不失一般性，样例只需要考虑可显示的字符（String）
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct IOData {
        fd: FileDescriptor,
        content: String,
    }

    /// 题目显示时的元数据，在渲染 pdf 题面时也会需要
    #[derive(Debug, Clone, Serialize, Deserialize, SerdeJsonWithType)]
    pub struct Meta {
        /// 标题
        title: String,
        /// 时间限制
        time: Option<Elapse>,
        /// 空间限制
        memory: Option<Memory>,
        /// 题目类型
        kind: Option<ProblemKind>,
    }
}

pub mod tutorial {
    use super::*;

    /// 题解
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Tutorial {
        pub tutorial: Inner,
        pub meta: Meta,
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub enum Inner {
        /// Markdown 文本
        Source(String),
        /// load from an pdf asset
        Pdf(PathBuf),
    }

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Meta {
        /// 题目来源、作者
        origin: Option<String>,
        /// 有关难度的描述
        difficulty: Option<String>,
        /// 算法标签
        tags: Vec<String>,
    }
}

pub use statement::Statement;
pub use tutorial::Tutorial;
